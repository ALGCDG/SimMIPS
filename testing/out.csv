ADD0, ADD, Pass, Archie, testing the addition of the zeroth register with its self storing the result in the zeroth register NB I am not sure what should happen in this case
ADD1, ADD, Pass, Archie, Testing for sign overflow exception (-10) adding two positive numbers and getting a negative number
ADD2, ADD, Fail, Archie, Testing for arithmatic exception behaviour (-10) adding two negative numbers and getting a positive number
ADDI0, ADDI, Pass, Archie, Adding zero and 7 and storing result in register 2
AND0, AND, Pass, Archie, Using $1 to mask a number in $3
ANDI0, ANDI, Pass, Archie, Using ANDI to mask a 8 bit number for only the lowest 4 bits
BEQ0, BEQ, Fail, Archie, Testing BEQ when registers are equal and branch occurs
BEQ1, BEQ, Pass, Archie, Testing BEQ when registers are not equal and no branch occurs
BGEZ0, BGEZ, Fail, Archie, Testing BGEZ when register is greater than zero
BGEZ1, BGEZ, Fail, Archie, Testing BGEZ when register is less than zero and no branch occurs
BGEZ2, BGEZ, Fail, Archie, Testing BGEZ when register is equal to zero
BGTZ0, BGTZ, Fail, Archie, Testing BGTZ when register is greater than zero
BGTZ1, BGTZ, Pass, Archie, Testing BGTZ when register is less than zero and no branch occurs
BGTZ2, BGTZ, Pass, Archie, Testing BGTZ when register is equal to zero and no branch occurs
BLEZ0, BLEZ, Fail, Archie, Testing BLEZ when register is less than zero
BLEZ1, BLEZ, Pass, Archie, Testing BLEZ when register is greater than zero and no branch occurs
BLEZ2, BLEZ, Fail, Archie, Testing BLEZ when register is equal to zero
BLTZ0, BLTZ, Fail, Archie, Testing BLTZ when register is less than zero
BLTZ1, BLTZ, Fail, Archie, Testing BLTZ when register is greater than zero and no branch occurs
BLTZ2, BLTZ, Fail, Archie, Testing BLTZ when register is equal to zero so no branch occurs
BNE0, BNE, Fail, Archie, Testing BNE when registers are not equal and branch occurs
BNE1, BNE, Pass, Archie, Testing BNE when registers are equal and no branch occurs
INTERNAL0, INTERNAL, Pass, Archie, Testing that all registers are initialised zero
INTERNAL1, INTERNAL, FAIL, NO BIN FILE
INTERNAL2, INTERNAL, FAIL, NO BIN FILE
INTERNAL3, INTERNAL, FAIL, NO BIN FILE
INTERNAL4, INTERNAL, FAIL, NO BIN FILE
INTERNAL7, INTERNAL, FAIL, NO BIN FILE
INTERNAL8, INTERNAL, FAIL, NO BIN FILE
J0, J, FAIL, NO BIN FILE
JR0, JR, Pass, Archie, JR jumping straight to NULL to end program
JR1, JR, Pass, Archie, Running ADD then SLL then SLL and a JR to null
JR2, JR, Pass, Archie, testing plane jump to null assembled
JR3, JR, Pass, Archie, Testing a Jump to null that is followed by several instructions (which ought not to execute)
LUI0, LUI, Pass, Archie, using LUI to load 0xffff into the upper half of the register two and testing that the lower half is uneffected
LUI1, LUI, Pass, Archie, using LUI to load 0x0001 into the upper half then shift right logically by 16
LUI2, LUI, FAIL, NO BIN FILE
LW0, LW, Pass, Archie, writing to the first address in data memory (0x20000000) then reading from it
MFHI0, MFHI, Fail, Archie, A basic test moving a value from one register to HI the moving from HI to register 2
MFLO0, MFLO, Fail, Archie, Basic test moving value from a register to LO then from LO to register 2
MTHI0, MTHI, Pass, Archie, moving a value (5) from register run to hi register
MTLO0, MTLO, Pass, Archie, testing moving a value (7) from register 3 to LO
OR0, OR, Pass, Jonathan, Result of OR in reg 2. ORs 5 in reg1 with 0 in reg 2
OR1, OR, Pass, Jonathan, OR 0b1000 with 0b1111 from regs 1, 2 -> 2
ORI0, ORI, Pass, Archie, Using ORI to load literal into register 2
SB0, SB, Pass, Jonathan, Store then read the same byte
SB1, SB, Pass, Jonathan, store byte then read exact same address
SB2, SB, Pass, Jonathan, negative offset from 0x200000 - should give mem exception
SB3, SB, Pass, Jonathan, Store byte out of upper limit: mem exception
SB4, SB, Fail, Jonathan, SB and PUTC test
SLL0, SLL, Pass, Archie, use addi to store 0x1 in $2 then SLL to shift left by 2 then jump to end
SLL1, SLL, Pass, Archie, use addi to put literal 1 in $2 then shift left by 8 until ought of return window
SLT0, SLT, Pass, Jonathan, Comparing two negative numbers (TRUE)
SLT1, SLT, Pass, Jonathan, Comparing two negative numbers (FALSE)
SLT2, SLT, Pass, Jonathan, testing negative less than positive
SLT3, SLT, Pass, Jonathan, testing pos < pos
SLT4, SLT, Pass, Jonathan, testing pos < neg
SLTU0, SLTU, Pass, Archie, Testing SLTU where comparison is true
SLTU1, SLTU, Pass, Archie, Testing SLTU in case where comparison is false
SLTU2, SLTU, Pass, Archie, Comparing a negative (under two's compliment) number with a positive number
SRLV0, SRLV, Pass, Jonathan, shift 0xFFFFFFFF right 31 times
SRLV1, SRLV, Pass, Jonathan, shift 0 right 
SRLV2, SRLV, Pass, Jonathan, shift right by 36 actually shifts by 4 -> 32 := 2
STACK0, STACK, FAIL, NO BIN FILE
STACK1, STACK, FAIL, NO BIN FILE
STACK2, STACK, FAIL, NO BIN FILE
STACK3, STACK, FAIL, NO BIN FILE
SUB0, SUB, Pass, Jonathan, pos - pos -> no overflow
SUB1, SUB, Pass, Jonathan, pos - neg -> no overflow
SUB2, SUB, Pass, Jonathan, neg - neg -> no overflow
SUB3, SUB, Pass, Jonathan, neg - pos -> no overflow
SUB4, SUB, Pass, Jonathan, big pos - big neg -> overflow
SUB5, SUB, Pass, Jonathan, big neg - big pos -> overflow
SUBU0, SUBU, Fail, Archie, invert a binary word by using SUBU with zero then add 1
SW0, SW, Pass, Archie, testing storing word in the first memory address of Data memory (0x20000000)
SW1, SW, Fail, Archie, Testing SW writing to the largest address in Data memory (0x23fffffb)
SW2, SW, Fail, Archie, Testing SW writing to some other address in Data memory (0x20ceff12)
SW3, SW, Pass, Archie, Testing writing SW to the PUTC address (0x30000004)
XOR0, XOR, Pass, Jonathan, xor of 0b10001 with 0b01110 (gives 0 as complement)
XOR1, XOR, Pass, Jonathan, XOR swap
