ADD0, ADD, Pass, Archie, testing the addition of the zeroth register with its self storing the result in the zeroth register this ought not cause any exception
ADD1, ADD, Pass, Archie, Testing for sign overflow exception (-10) adding two positive numbers and getting a negative number
ADD2, ADD, Pass, Archie, Testing for arithmatic exception behaviour (-10) adding two negative numbers and getting a positive number
ADDI0, ADDI, Pass, Archie, Adding zero and 7 and storing result in register 2
ADDI1, ADDI, Fail, Archie, Testing for sign overflow exception (-10) adding two positive numbers and getting a negative number
ADDI2, ADDI, Fail, Archie, Testing for arithmatic exception behaviour (-10) adding two negative numbers and getting a positive number
AND0, AND, Pass, Archie, Using $1 to mask a number in $3
ANDI0, ANDI, Pass, Archie, Using ANDI to mask a 8 bit number for only the lowest 4 bits
BEQ0, BEQ, Pass, Archie, Testing BEQ when registers are equal and branch occurs
BEQ1, BEQ, Pass, Archie, Testing BEQ when registers are not equal and no branch occurs
BGEZ0, BGEZ, Fail, Archie, Testing BGEZ when register is greater than zero
BGEZ1, BGEZ, Fail, Archie, Testing BGEZ when register is less than zero and no branch occurs
BGEZ2, BGEZ, Fail, Archie, Testing BGEZ when register is equal to zero
BGEZAL0, BGEZAL, Fail, Archie, Testing calling a subroutine when the condition is met
BGEZAL1, BGEZAL, Fail, Archie, Testing calling a subroutine when the condition is met (zero)
BGEZAL2, BGEZAL, Fail, Archie, Testing not calling a subroutine when the condition is not met (number in register is negative)
BGTZ0, BGTZ, Pass, Archie, Testing BGTZ when register is greater than zero
BGTZ1, BGTZ, Pass, Archie, Testing BGTZ when register is less than zero and no branch occurs
BGTZ2, BGTZ, Pass, Archie, Testing BGTZ when register is equal to zero and no branch occurs
BLEZ0, BLEZ, Pass, Archie, Testing BLEZ when register is less than zero
BLEZ1, BLEZ, Pass, Archie, Testing BLEZ when register is greater than zero and no branch occurs
BLEZ2, BLEZ, Pass, Archie, Testing BLEZ when register is equal to zero
BLTZ0, BLTZ, Fail, Archie, Testing BLTZ when register is less than zero
BLTZ1, BLTZ, Fail, Archie, Testing BLTZ when register is greater than zero and no branch occurs
BLTZ2, BLTZ, Fail, Archie, Testing BLTZ when register is equal to zero so no branch occurs
BLTZAL0, BLTZAL, Fail, Archie, Testing calling a subroutine when the condition is met
BLTZAL1, BLTZAL, Fail, Archie, Testing not calling a subroutine when the condition is not met (number in register is positive)
BLTZAL2, BLTZAL, Fail, Archie, Testing not calling a subroutine when the condition is not met (number in register is zero)
BNE0, BNE, Pass, Archie, Testing BNE when registers are not equal and branch occurs
BNE1, BNE, Pass, Archie, Testing BNE when registers are equal and no branch occurs
DIV0, DIV, Pass, Archie, Testing division 1/1 and testing quotient
DIV1, DIV, Pass, Archie, Testing division 1/1 and testing remainder
DIV10, DIV, Fail, Archie, Testing division of a positive number by a negative 2's compliment number and testing remainder which must have the same sign as the dividend (so we expect it to be positive)
DIV11, DIV, Fail, Archie, Testing division of a negative 2's compliment number by a positive number and testing remainder which must have the same sign as the dividend (so we expect it to be negative)
DIV2, DIV, Fail, Archie, Testing division 79 / 1 and testing quotient
DIV3, DIV, Pass, Archie, Testing division 79 / 1 and testing remainder
DIV4, DIV, Fail, Archie, Testing that there is NO arithmetic exception when dividing a number by zero (MIPS reference sheet is very explicit about this, there must be no exception)
DIV5, DIV, Pass, Archie, Testing the divison of a prime (3) / 2 and testing quotient
DIV6, DIV, Pass, Archie, Testing the divison of a prime (3) / 2 and testing remainder
DIV7, DIV, Fail, Archie, Testing division of two negative 2's compliment numbers and testing quotient which we expect to be positive
DIV8, DIV, Fail, Archie, Testing division of a positive number by a negative 2's compliment number and testing quotient which we expect to be negative
DIV9, DIV, Pass, Archie, Testing division of a negative 2's compliment number and a positive number and testing quotient which we expect to be negative
DIVU0, DIVU, Pass, Archie, Testing unsigned division 1/1 and testing quotient
DIVU1, DIVU, Pass, Archie, Testing unsigned division 1/1 and testing remainder
DIVU2, DIVU, Fail, Archie, Testing unsigned division 79 / 1 and testing quotient
DIVU3, DIVU, Pass, Archie, Testing unsigned division 79 / 1 and testing remainder
DIVU4, DIVU, Fail, Archie, Testing that there is NO arithmetic exception when dividing a number by zero (MIPS reference sheet is very explicit about this, there must be no exception)
DIVU5, DIVU, Pass, Archie, Testing the unsigned divison of a prime (3) / 2 and testing quotient
DIVU6, DIVU, Pass, Archie, Testing the unsigned divison of a prime (3) / 2 and testing remainder
DIVU7, DIVU, Pass, Archie, Testing division of negative 2's compliment number with positive number and testing quotient which we expect to be positive
FUNCTION0, FUNCTION, Fail, Archie, Testing a function that returns int
FUNCTION1, FUNCTION, Fail, Archie, Testing a function that returns char
FUNCTION2, FUNCTION, Fail, Archie, Testing a function that returns double
FUNCTION3, FUNCTION, Fail, Archie, Testing a function that returns float
FUNCTION4, FUNCTION, Fail, Archie, Testing a function that returns bool
FUNCTION5, FUNCTION, Fail, Archie, Testing a function that returns void (and passes an int pointer)
FUNCTION6, FUNCTION, FAIL, NO BIN FILE
INTERNAL0, INTERNAL, Pass, Archie, Testing that all registers are initialised zero
INTERNAL1, INTERNAL, FAIL, NO BIN FILE
INTERNAL2, INTERNAL, FAIL, NO BIN FILE
INTERNAL3, INTERNAL, FAIL, NO BIN FILE
INTERNAL4, INTERNAL, FAIL, NO BIN FILE
INTERNAL7, INTERNAL, Pass, Archie, Testing a C program that uses a while loop
INTERNAL8, INTERNAL, Pass, Archie, Testing a C program that uses a for loop
J0, J, Pass, Archie, Testing J to skip over an instruction
J1, J, Fail, Archie, Writing a program that uses slightly more complicated jumps
JAL0, JAL, FAIL, NO BIN FILE
JAL1, JAL, FAIL, NO BIN FILE
JALR0, JALR, Fail, Archie, Implementing and calling a simple subroutine (succ) using JALR
JALR1, JALR, Fail, Archie, Implementing and calling (repeatedly) a simple subroutine (succ) using JAL
JR0, JR, Pass, Archie, JR jumping straight to NULL to end program
JR1, JR, Pass, Archie, Running ADD then SLL then SLL and a JR to null
JR2, JR, Pass, Archie, testing plane jump to null assembled
JR3, JR, Pass, Archie, Testing a Jump to null that is followed by several instructions (which ought not to execute)
LB0, LB, Pass, Jonathan, checking exclusively for issues with signed extension
LB1, LB, Pass, Jonathan, checking LB with out of range address
LB2, LB, Pass, Jonathan, checking LB with byte offset and sign extension
LBU0, LBU, Pass, Jonathan, same code as LB0 to check difference with unsigned
LBU1, LBU, Pass, Jonathan, with byte offset
LBU2, LBU, Pass, Jonathan, Reading byte from instruction memory
LUI0, LUI, Pass, Archie, using LUI to load 0xffff into the upper half of the register two and testing that the lower half is uneffected
LUI1, LUI, Pass, Archie, using LUI to load 0x0001 into the upper half then shift right logically by 16
LUI2, LUI, Pass, Archie, using LUI to load 0x8000 the slr by 31
LW0, LW, Pass, Archie, writing to the first address in data memory (0x20000000) then reading from it
MFHI0, MFHI, Pass, Archie, A basic test moving a value from one register to HI the moving from HI to register 2
MFLO0, MFLO, Pass, Archie, Basic test moving value from a register to LO then from LO to register 2
MTHI0, MTHI, Pass, Archie, moving a value (5) from register run to hi register
MTLO0, MTLO, Pass, Archie, testing moving a value (7) from register 3 to LO
MULT0, MULT, Pass, Archie, Testing multiplication of 1 by 1
MULT1, MULT, Pass, Archie, Testing multiplication of 1 by 0
MULT2, MULT, Fail, Archie, Testing 16 bit multiplication
MULT3, MULT, Fail, Archie, Testing 32 bit multiplication
MULT4, MULT, Pass, Archie, Testing signed multiplication of a 16 bit positive number with a 16 bit negative number (expecting a 32bit negative product)
MULT5, MULT, Fail, Archie, Testing signed multiplication of a 16 bit negative number with a 16 bit negative number (expecting a 32bit positive product)
MULT6, MULT, Fail, Archie, Testing signed multiplication of a 32 bit negative number with a 32 bit positive number (expecting a 64bit negative product)
MULT7, MULT, Fail, Archie, Testing signed multiplication of a 32 bit negative number with a 32 bit negative number (expecting a 64bit positive product)
MULTU0, MULTU, Pass, Archie, Testing multiplication of 1 by 1
MULTU1, MULTU, Pass, Archie, Testing multiplication of 1 by 0
MULTU2, MULTU, Fail, Archie, Testing 16 bit unsigned multiplication
MULTU3, MULTU, Fail, Archie, Testing 32 bit unsigned multiplication
OR0, OR, Pass, Jonathan, Result of OR in reg 2. ORs 5 in reg1 with 0 in reg 2
OR1, OR, Pass, Jonathan, OR 0b1000 with 0b1111 from regs 1, 2 -> 2
ORI0, ORI, Pass, Archie, Using ORI to load literal into register 2
SB0, SB, Pass, Jonathan, Store then read the same byte - checks non alligned byte
SB1, SB, Pass, Jonathan, store byte then read exact same address - checks concatenation
SB2, SB, Pass, Jonathan, negative offset from 0x200000 - should give mem exception
SB3, SB, Pass, Jonathan, Store byte out of upper limit: mem exception
SH0, SH, Pass, Jonathan, simple store half then load word (aligned)
SLL0, SLL, Pass, Archie, use addi to store 0x1 in $2 then SLL to shift left by 2 then jump to end
SLL1, SLL, Pass, Archie, use addi to put literal 1 in $2 then shift left by 8 until ought of return window
SLT0, SLT, Pass, Jonathan, Comparing two negative numbers (TRUE)
SLT1, SLT, Pass, Jonathan, Comparing two negative numbers (FALSE)
SLT2, SLT, Pass, Jonathan, testing negative less than positive
SLT3, SLT, Pass, Jonathan, testing pos < pos
SLT4, SLT, Pass, Jonathan, testing pos < neg
SLTU0, SLTU, Pass, Archie, Testing SLTU where comparison is true
SLTU1, SLTU, Pass, Archie, Testing SLTU in case where comparison is false
SLTU2, SLTU, Pass, Archie, Comparing a negative (under two's compliment) number with a positive number
SRLV0, SRLV, Pass, Jonathan, shift 0xFFFFFFFF right 31 times
SRLV1, SRLV, Pass, Jonathan, shift 0 right 
SRLV2, SRLV, Pass, Jonathan, shift right by 36 actually shifts by 4 -> 32 := 2
STACK0, STACK, Fail, Archie, calling one function inside anthor
STACK1, STACK, Fail, Archie, testing the succ of succ of succ of 0
STACK2, STACK, Fail, Archie, Testing a swap by pointer function (and function local variables)
STACK3, STACK, Fail, Archie, Finding the 13th (any larger and it wont fit in a char) fibonacci term (testing recursive functions)
SUB0, SUB, Pass, Jonathan, pos - pos -> no overflow
SUB1, SUB, Pass, Jonathan, pos - neg -> no overflow
SUB2, SUB, Pass, Jonathan, neg - neg -> no overflow
SUB3, SUB, Pass, Jonathan, neg - pos -> no overflow
SUB4, SUB, Pass, Jonathan, big pos - big neg -> overflow
SUB5, SUB, Pass, Jonathan, big neg - big pos -> overflow
SUBU0, SUBU, Fail, Archie, invert a binary word by using SUBU with zero then add 1
SW0, SW, Pass, Archie, testing storing word in the first memory address of Data memory (0x20000000)
SW1, SW, Fail, Archie, Testing SW writing to the largest address in Data memory (0x23fffffb)
SW2, SW, Fail, Archie, Testing SW writing to some other address in Data memory (0x20ceff12)
SW3, SW, Pass, Archie, Testing writing SW to the PUTC address (0x30000004)
XOR0, XOR, Pass, Jonathan, xor of 0b10001 with 0b01110 (gives 0 as complement)
XOR1, XOR, Pass, Jonathan, XOR swap
XORI0, XORI, Pass, Archie, Using XORI to load literal into register
XORI1, XORI, Pass, Archie, Using XORI to xor a literal and a register value
